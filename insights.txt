embora 'contracts' seja uma entidade separada no banco, acho que desasociar ela da entidade em memÃ³ria transaction iria adicionar mais complexidade com pouco beneficio. 
O acoplamento do objeto contract dentro de empenho nÃ£o Ã© muito ideal, mas como
o e escopo dos dados e modelos estÃ£o bem fechados sem margem pra expansÃ£o, acho que os beneficios serÃ£o maiores que os maleficios


--emps

Conceitualmente:

Contrato: instrumento jurÃ­dico que cria a obrigaÃ§Ã£o

Empenho: ato contÃ¡bil que reserva dotaÃ§Ã£o orÃ§amentÃ¡ria para pagar essa obrigaÃ§Ã£o

ðŸ“Œ Um mesmo contrato pode gerar vÃ¡rios empenhos por razÃµes legÃ­timas.

2. SituaÃ§Ãµes legÃ­timas (e comuns) de mÃºltiplos empenhos
2.1 ExecuÃ§Ã£o parcelada do contrato

Exemplo:

Contrato anual de manutenÃ§Ã£o

Pagamentos mensais

Contrato
 â”œâ”€ Empenho Jan
 â”œâ”€ Empenho Fev
 â”œâ”€ Empenho Mar


 Embora o schema do banco nÃ£o imponha chaves estrangeiras entre contrato, empenho e fornecedor, o domÃ­nio da despesa pÃºblica estabelece que todo empenho herda obrigatoriamente 
 o fornecedor definido no contrato, sendo invÃ¡lida qualquer divergÃªncia entre o credor do empenho e o fornecedor contratado.

 ontrato
  â”œâ”€â”€ fornecedor (1)
  â”œâ”€â”€ entidade (1)
  â””â”€â”€ empenhos (N)
        â”œâ”€â”€ liquidaÃ§Ãµes (N)
        â”‚     â””â”€â”€ NFe (1)
        â””â”€â”€ pagamentos (N)

        Na execuÃ§Ã£o orÃ§amentÃ¡ria brasileira:

Um Contrato pode:

Ser empenhado integralmente

Ser empenhado parcialmente

Ter reforÃ§o de empenho

Ter empenhos distribuÃ­dos por exercÃ­cios diferentes

Ter empenhos por etapas/fases



Contract
  â”œâ”€â”€ EmpenhoTransaction
  â”‚     â””â”€â”€ Empenhos (List)
  â””â”€â”€ EmpenhosLiquidados (List)
        â””â”€â”€ EmpenhoLiquidado
              â”œâ”€â”€ Empenho
              â”œâ”€â”€ Liquidacao
              â””â”€â”€ NFe

            
import sys
import os
from dataclasses import dataclass
from typing import List, Optional
from result import Result
current_dir = os.path.dirname(os.path.abspath(__file__))
project_root = os.path.abspath(os.path.join(current_dir, "../../"))
if project_root not in sys.path:
    sys.path.append(project_root)

from models.empenho import Empenho
from models.nfe import Nfe
from models.liquidacao_nota_fiscal import LiquidacaoNotaFiscal
from clientside.transaction.empenho_transaction import EmpenhoTransaction

##nesse modulo hÃ¡ duplicaÃ§Ã£o do ob jeto Empenho. Pensei em alterar a estrutura de dados que armazena Empenhos em EmpenhosTransaction para um map() com o id_empenho como chave,
# e gara ntir acesso controlado via getters para manter imutabilidade, e a partir dai armazenar List[EmpenhosLiquidados] via referencia ao ID de empenhos
#mas nÃ£o sei se vai dar tempo, entÃ£o To-Do
@dataclass(frozen=True)
class EmpenhoLiquidado:
    empenho: Empenho
    liquidacao: LiquidacaoNotaFiscal
    nfe: Optional[Nfe] # NFe is optional if not found or not strictly required by hard constraint yet

@dataclass
class LiquidacaoTransaction:
    empenho_transaction: EmpenhoTransaction
    empenhos_liquidados: List[EmpenhoLiquidado]

    @staticmethod
    def _fetch_liquidacao_pair(empenho: Empenho) -> Result[Optional[EmpenhoLiquidado]]:
        """
        Tries to fetch Liquidacao and NFe for a given Empenho.
        If Liquidacao not found, returns Ok(None) - meaning this empenho is not liquidated yet.
        """
        res_liq = LiquidacaoNotaFiscal.get_by_FK_id_empenho(empenho.id_empenho)
        
        if res_liq.is_err:
             # Logic decision: Is it an error or just 'not liquidated'? 
             # For now, let's assume it's valid to not be liquidated.
             # But if get_by_FK returns error for "not found", we handle it.
             # Assuming 'not found' might appear as empty or specific error. 
             # For simplicity here: if error, we treat as not liquidated (None).
             return Result.ok(None)
        
        liquidacao = res_liq.value
        
        # Fetch NFe
        res_nfe = Nfe.get_by_chave_nfe_FK(liquidacao.chave_danfe)
        nfe = res_nfe.value if res_nfe.is_ok else None
        
        return Result.ok(EmpenhoLiquidado(
            empenho=empenho,
            liquidacao=liquidacao,
            nfe=nfe
        ))

    @staticmethod
    def build_from_empenho_transaction(transaction_result: Result[EmpenhoTransaction]) -> Result["LiquidacaoTransaction"]:
        
        if transaction_result.is_err:
            return Result.err(transaction_result.error)

        transaction = transaction_result.value
        empenhos_liquidados: List[EmpenhoLiquidado] = []

        for empenho in transaction.empenhos:
    
            res_pair = LiquidacaoTransaction._fetch_liquidacao_pair(empenho)
            if res_pair.is_err:
                # Decide if we block the whole transaction or just skip.
                # Let's return error to be safe/strict for now.
                return Result.err(f"Error fetching liquidacao for empenho {empenho.id_empenho}: {res_pair.error}")
            
            if res_pair.value:
                empenhos_liquidados.append(res_pair.value)

        return Result.ok(LiquidacaoTransaction(
            empenho_transaction=transaction,
            empenhos_liquidados=empenhos_liquidados
        ))


