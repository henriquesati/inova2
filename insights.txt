embora 'contracts' seja uma entidade separada no banco, acho que desasociar ela da entidade em memÃ³ria transaction iria adicionar mais complexidade com pouco beneficio. 
O acoplamento do objeto contract dentro de empenho nÃ£o Ã© muito ideal, mas como
o e escopo dos dados e modelos estÃ£o bem fechados sem margem pra expansÃ£o, acho que os beneficios serÃ£o maiores que os maleficios


--emps

Conceitualmente:

Contrato: instrumento jurÃ­dico que cria a obrigaÃ§Ã£o

Empenho: ato contÃ¡bil que reserva dotaÃ§Ã£o orÃ§amentÃ¡ria para pagar essa obrigaÃ§Ã£o

ğŸ“Œ Um mesmo contrato pode gerar vÃ¡rios empenhos por razÃµes legÃ­timas.

2. SituaÃ§Ãµes legÃ­timas (e comuns) de mÃºltiplos empenhos
2.1 ExecuÃ§Ã£o parcelada do contrato

Exemplo:

Contrato anual de manutenÃ§Ã£o

Pagamentos mensais

Contrato
 â”œâ”€ Empenho Jan
 â”œâ”€ Empenho Fev
 â”œâ”€ Empenho Mar


 Embora o schema do banco nÃ£o imponha chaves estrangeiras entre contrato, empenho e fornecedor, o domÃ­nio da despesa pÃºblica estabelece que todo empenho herda obrigatoriamente 
 o fornecedor definido no contrato, sendo invÃ¡lida qualquer divergÃªncia entre o credor do empenho e o fornecedor contratado.

 ontrato
  â”œâ”€â”€ fornecedor (1)
  â”œâ”€â”€ entidade (1)
  â””â”€â”€ empenhos (N)
        â”œâ”€â”€ liquidaÃ§Ãµes (N)
        â”‚     â””â”€â”€ NFe (1)
        â””â”€â”€ pagamentos (N)

        Na execuÃ§Ã£o orÃ§amentÃ¡ria brasileira:

Um Contrato pode:

Ser empenhado integralmente

Ser empenhado parcialmente

Ter reforÃ§o de empenho

Ter empenhos distribuÃ­dos por exercÃ­cios diferentes

Ter empenhos por etapas/fases



Contract
  â”œâ”€â”€ EmpenhoTransaction
  â”‚     â””â”€â”€ Empenhos (List)
  â””â”€â”€ EmpenhosLiquidados (List)
        â””â”€â”€ EmpenhoLiquidado
              â”œâ”€â”€ Empenho
              â”œâ”€â”€ Liquidacao
              â””â”€â”€ NFe

            
import sys
import os
from dataclasses import dataclass
from typing import List, Optional
from result import Result
current_dir = os.path.dirname(os.path.abspath(__file__))
project_root = os.path.abspath(os.path.join(current_dir, "../../"))
if project_root not in sys.path:
    sys.path.append(project_root)

from models.empenho import Empenho
from models.nfe import Nfe
from models.liquidacao_nota_fiscal import LiquidacaoNotaFiscal
from clientside.transaction.empenho_transaction import EmpenhoTransaction

##nesse modulo hÃ¡ duplicaÃ§Ã£o do ob jeto Empenho. Pensei em alterar a estrutura de dados que armazena Empenhos em EmpenhosTransaction para um map() com o id_empenho como chave,
# e gara ntir acesso controlado via getters para manter imutabilidade, e a partir dai armazenar List[EmpenhosLiquidados] via referencia ao ID de empenhos
#mas nÃ£o sei se vai dar tempo, entÃ£o To-Do

validaÃ§Ã£o tbm dep ende do fl uxo de dados? por exemplo se entities on the middle are none, Do I have to still verify end entities?
2. Contratos podem ser performados por muitos empenhos?
 - Nessa modelagem eu admiti que sim, o que muda um pouco a lÃ³gica de modelagem e validaÃ§Ã£o2
 
2. Contratos podem ser performados por muitos empenhos?
 - Nessa modelagem eu admiti que sim, o que muda um pouco a lÃ³gica de modelagem e validaÃ§Ã£o2
 
2. Contratos podem ser performados por muitos empenhos?
 - Nessa modelagem eu admiti que sim, o que muda um pouco a lÃ³gica de modelagem e validaÃ§Ã£o2
 
os dados de exemplo, cada empenho aparece com apenas uma liquidaÃ§Ã£o/NFe,
mas isso Ã© comportamento do dataset, nÃ£o uma restriÃ§Ã£o estrutural

NumeraÂ¸cËœao Â´unica do documento fiscal. asset